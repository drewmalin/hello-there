import argparse
import re
import sys

HEADER_COMMENT = """###
# This Makefile was automatically generated by 'makemake.py'
# 
# Directly modifying this Makefile is allowed, but modifications may be overwritten by further uses of the makemake utility.
###
"""

TARGETS_COMMENT = """###
# Targets:
###
"""

OBJECTS_COMMENT = """###
# Intermediary objects:
###
"""

REGEX_POUND_INCLUDE = re.compile("#include\s\"(.*)\"")

MAIN = "main.c"
OUT = "main.out"
MAKEFILE = "Makefile"

SRCDIR     = "src"
INCLUDEDIR = "include"
BUILDDIR   = "obj"
BINDIR     = "bin"

SRCEXT = "c"
OBJEXT = "o"
HDREXT = "h"
OUTEXT = "out"

CC      = "clang"
CFLAGS  = "-Wall -Wextra -std=c2x -pedantic"
LDFLAGS = ""
DBFLAGS = "-g3 -glldb"

MODE_RELEASE = "RELEASE"
MODE_DEBUG   = "DEBUG"

def main(argv):
    argParser = argparse.ArgumentParser(description="A maker of Makefiles")

    argParser.add_argument("-v", 
                           "--verbose", 
                           action="store_true", 
                           help="Verbose output")
    argParser.add_argument("-m", 
                           "--mains", 
                           nargs="+",
                           action="extend",
                           type=str,
                           help=f"Main file (defaults to: {SRCDIR}/{MAIN})")
    argParser.add_argument("-o", 
                           "--out", 
                           default=OUT,
                           help=f"Output file (defaults to: {OUT})")
    argParser.add_argument("--cc",
                           default=CC,
                           help=f"Compiler (defaults to: {CC})")
    argParser.add_argument("--cflags",
                           default=CFLAGS,
                           help=f"Compiler flags (defaults to: {CFLAGS})")
    argParser.add_argument("--ldflags",
                           default=LDFLAGS,
                           help=f"Linker flags (defaults to: {LDFLAGS})")
    argParser.add_argument("--mode",
                           default=MODE_RELEASE,
                           choices=[MODE_RELEASE, MODE_DEBUG],
                           help=f"Compile mode (defaults to: {MODE_RELEASE})")
    argParser.add_argument("--srcdir",
                           default=SRCDIR,
                           help=f"Directory for source files (defaults to: {SRCDIR})")
    argParser.add_argument("--bindir",
                           default=BINDIR,
                           help=f"Directory for final binary file (defaults to: {BINDIR})")
    argParser.add_argument("--builddir",
                           default=BUILDDIR,
                           help=f"Directory for intermediary build files (defaults to: {BUILDDIR})")
    argParser.add_argument("--srcext",
                           default=SRCEXT,
                           help=f"Extension for all source files (defaults to: {SRCEXT})")
    argParser.add_argument("--objext",
                           default=OBJEXT,
                           help=f"Extension for all object files (defaults to: {OBJEXT})")
    argParser.add_argument("--hdrext",
                           default=HDREXT,
                           help=f"Extension for all header files (defaults to: {HDREXT})")
    argParser.add_argument("--makefile",
                           default=MAKEFILE,
                           help=f"The name of the final Makefile (defaults to: {MAKEFILE})")

    args = argParser.parse_args()
    makemake(args)

##
# Entrypoint.
#
def makemake(args):
    header = make_header(args)
    linker_target = make_linker_target(args)
    object_targets = make_object_targets(args)
    static_targets = make_static_targets(args)
    
    if args.verbose:
        out = header + linker_target + '\n'.join(t for t in object_targets) + static_targets
        debug("makemake", "", out)
    
    with open(args.makefile, 'w') as out:
        out.write(f'{HEADER_COMMENT}\n')
        out.write(header)
        out.write(f'{TARGETS_COMMENT}\n')
        out.write(linker_target)
        out.write(f'{OBJECTS_COMMENT}\n')
        for t in object_targets:
            out.write(t + '\n')
        out.write(static_targets)

def make_header(args):
    cflags = args.cflags + " " + DBFLAGS if args.mode == MODE_DEBUG else args.cflags

    out = (
        f'CC      := {args.cc}\n'
        f'CFLAGS  := {cflags}\n'
        f'LDFLAGS := {args.ldflags}\n'
        f'\n.DEFAULT_GOAL: all\n\n'
        '\n'
    )
    return out

##
# Creates a make target for the final linking step for this project. Usually a project has only one entrypoint, but in the
# event that more than one exist (say, one for a CLI, one for a server, or one for tests) then each can be specified and
# passed to this function. For each entrypoint, a binary is linked.
#
def make_linker_target(args):
    all = []
    out = ""
    
    for main in args.mains:
        main_object_files = set()
        
        # The final target always directly depends upon itself (or at least, its source representation)!
        main_object_file = source_to_object(main, args)
        main_object_files.add(main_object_file)

        # Generate all #included dependencies of 'main'
        main_includes = get_included_headers(main, args)
        for h in main_includes:
            main_object_files.add(header_to_object(h, args))
        
        main_object_files_string = ' '.join(main_object_files)
        main_out = source_to_out(main, args)

        # Maintain a list of all targets for later
        all.append(main_out)

        # Build the target for the final binary (linker step)
        out = out + (
            f'{main_out} : {main_object_files_string}\n'
            f'\t@mkdir -p {args.bindir}\n'
            f'\t${{CC}} ${{LDFLAGS}} -o {main_out} {main_object_files_string}\n'
            f'\n'
        )

    if args.verbose:
        debug("make_main_target", "", out)

    return f'all: {" ".join(all)}\n\n{out}'

##
# Creates a make target for all source files referenced from the main file in this project. Beginning with the main
# file, a make target is created for each included header file. Each header file is assumed to correspond to a local
# source file, meaning each header file will be used to generate an object file which depends upon this source file
# and all denoted header files.
# 
# See 'make_object_target'
def make_object_targets(args):
    targets = set()
    todo_headers = set()

    # Begin with the main file and crawl the "includes" tree
    for main in args.mains:
        main_headers, target = make_object_target(main, args)
        targets.add(target)
        todo_headers.update(main_headers)

    completed_headers = set()
    while len(todo_headers) > 0:

        # Process the next header, walking to its source file and generating a target
        header = todo_headers.pop()
        source = header_to_source(header, args)
        completed_headers.add(header)
        
        next_headers, target = make_object_target(source, args)
        targets.add(target)

        # For all included headers of the just-finished file, only maintain those which we have not yet
        # processed.
        for h in next_headers:
            if h in completed_headers:
                continue
            else:
                todo_headers.add(h)

    if args.verbose:
        debug("make_object_targets", "", targets)
    
    return targets

##
# Creates a make target for the provided header filepath. The filepath is expected to be in the form that would
# be seen in a C or C++ file, meaning it is not a complete directory (notably it should be missing a leading "src/"
# if appropriate). Given this header file, two outputs are generated: the list of header files that this file's
# source includes (so that further targets may be made) and the final target string itself.
#
# Example:
#
# foo.c:
#   #include <stdio.h>
#   #include "foo/bar.h"
#
# make_object_target("foo.c") =>
# tuple(0):
#   foo.o : foo.c bar.h
#       clang -Wall -c src/foo.c -o obj/foo.o
# tuple(1):
#   {"bar.h"}
#
def make_object_target(source_file, args):
    object_file = source_to_object(source_file, args)
    headers = get_included_headers(source_file, args)

    out = (
        f'{object_file} : {source_file}\n'
        f'\t@mkdir -p $(dir {object_file})\n'
        f'\t${{CC}} ${{CFLAGS}} -I{INCLUDEDIR} -c {source_file} -o {object_file}\n'
    )

    if args.verbose:
        debug("make_object_target", "", out)

    return headers, out

##
# Creates static targets that always exist regardless of the source tree (a typical example is the 'clean' target).
#
def make_static_targets(args):
    target_clean = (
        f'.PHONY : clean\n'
        f'clean :\n'
        f'\trm -rf {args.builddir}\n'
    )
    target_purge = (
        f'.PHONY : purge\n'
        f'purge : clean\n'
        f'\trm -rf {args.bindir}\n'
    )
    return '\n'.join([target_clean, target_purge])

##
# Searches for all of the '#include "..."' lines in file specified by the provided filepath.
# For each example of the '#include "..."', the inner included path will be returned in a set.
#
# Example:
#
# main.c:
#   #include <stdio.h>
#   #include "foo/bar.h"
#   #include "foo/baz.h"
#
# get_included_headers("main.c", args) => {"foo/bar.h", "foo/baz.h"}
#
def get_included_headers(filepath, args):
    includes = set()
    with open(filepath) as f:
        for line in f:
            match = re.search(REGEX_POUND_INCLUDE, line)
            if not match:
                continue

            include = match.group(1)
            includes.add(include)

    if args.verbose:
        debug("get_included_headers", filepath, includes)

    return includes

##
# Returns a string representing the provided filepath with the header extension replaced by the
# object extension.
#
# Example:
#
# objext = o
# hdrext = h
#
# header_to_object("foo/bar.h", args) => "obj/foo/bar.o"
#
def header_to_object(filepath, args):
    out = filepath.replace(args.hdrext, args.objext)
    out = f'{args.builddir}/{out}'

    if args.verbose:
        debug("header_to_object", filepath, out)

    return out

##
# Returns a string representing the provided filepath with the header extension replaced by the
# source extension.
#
# Example:
#
# srcext = c
# hdrext = h
#
# header_to_source("foo/bar.h", args) => "src/foo/bar.c"
#
def header_to_source(filepath, args):
    out = filepath.replace(args.hdrext, args.srcext)
    out = f'{args.srcdir}/{out}'

    if args.verbose:
        debug("header_to_source", filepath, out)

    return out

##
# Returns a string representing the provided filepath with the source extension replaced by the
# object extension.
#
# Example:
#
# srcext = c
# objext = o
#
# source_to_object("src/foo/bar.c", args) => "obj/foo/bar.o"
#
def source_to_object(filepath, args):
    out = filepath.replace(args.srcext, args.objext)
    out = re.sub(r'^.*?\/', f'{args.builddir}/', out)

    if args.verbose:
        debug("source_to_object", filepath, out)

    return out

##
# Returns a string representing the provided filepath with the source extension replaced by the
# out extension.
#
# Example:
#
# srcext = c
# objext = o
#
# source_to_out("src/foo/bar.c", args) => "bin/foo/bar.out"
#
def source_to_out(filepath, args):
    out = filepath.replace(args.srcext, OUTEXT)
    out = re.sub(r'^.*?\/', f'{args.bindir}/', out)

    if args.verbose:
        debug("source_to_out", filepath, out)

    return out

def debug(function, input, output):
    print(f"{function}('{input}') =>\n{output}\nend {function}\n")

##
# Program entrypoint
#
if __name__ == '__main__':
    main(sys.argv[1:])
